"--------------------------------------------------------------------------------
" Configurations for Vim ( +lua, +python )
" Jyd  2019-12-31 12:50
"--------------------------------------------------------------------------------
set nocompatible " Disable compatibility with vi 

"filetype plugin indent on
let $VIMFILES=fnamemodify(resolve(expand('<sfile>:p')), ':h')
set rtp^=$VIMFILES

if $VIM_MODE =~ 'man'
  source $VIMFILES/bundles-man.vim
elseif $VIM_MODE =~ 'ycm'
  let g:did_coc_loaded = 1  " Disable COC
else
  let $VIM_MODE = 'coc'
  let g:loaded_youcompleteme = 1  " Disable YCM
endif

if exists('g:vscode')
  source $VIMFILES/vscode.vim
else
  source $VIMFILES/bundles.vim
endif

set rtp+=$VIMFILES/after

set nocscopeverbose
set ruler
set showcmd

set nolazyredraw
set shiftwidth=2
set tabstop=2
set expandtab

set nowrap
set hlsearch
set incsearch
set number
" set relativenumber
set ignorecase smartcase " Only be case sensitive when search contains uppercase
set nocursorcolumn
set hidden " allow we leave from the current modified buffer
set autoindent
set smartindent
set nobackup nowb noswf
set nowritebackup
set backupcopy=yes
set showmatch
set cmdheight=2
set history=100
set mouse=a         " enable mouse
set updatetime=300  " Smaller updatetime for CursorHold & CursorHoldI
set shortmess+=c    " don't give |ins-completion-menu| messages.
set signcolumn=yes  " always show signcolumns

set foldmethod=indent
set foldlevelstart=0
set foldnestmax=10
set nofoldenable

" Eliminating delays on ESC
set timeoutlen=1000 ttimeoutlen=30
set scrolloff=2
set guioptions-=T
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,gbk,gb18030
set wildmenu " show a navigable menu for tab completion
set wildmode=list:longest,full
set wildignore+=*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux
set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe  " Windows
set wildignore+=*DS_Store
set completeopt=menuone,longest,preview,noselect
"set t_ti= t_te= Keep screen after vim exited

if has("gui_running") && !has('gui_vimr')
  set ballooneval
  set balloondelay=100
endif

if has('termguicolors')
  set termguicolors
  " Correct RGB escape codes for vim inside tmux
  if !has('nvim') && $TERM ==# 'screen-256color'
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  endif
endif

set path=.,./include/**/*,/usr/local/include,/usr/include

" Default sh is Bash
let g:bash_is_sh=1

" define a group `vimrc` and initialize it.
augroup vimrc
  autocmd!
augroup END

" persistent undo
if has('nvim')
set undodir=$HOME/undodir
else
set undodir=$HOME/undodir8
endif
set undolevels=1000 "maximum number of set changes that can be undone
set undoreload=10000 "maximum number lines to save for undo on a buffer reload
set undofile

" copy & paste
set clipboard+=unnamed
vnoremap p "_dP

" define leader char
let g:mapleader = ","
let g:maplocalleader = ","

" status line
" set statusline=\ %F%m%r%h\ %w\ %y\ %{getcwd()}\ \ \ Line:\ %l/%L:%c
set laststatus=2


" enable syntax highlighting
syntax on
syntax sync minlines=256
set synmaxcol=300

if has("win32")
  source $VIMRUNTIME/mswin.vim
  if has('termencoding')
    set termencoding=gb2312
  endif
  if has('directx')
    set renderoptions=type:directx,level:0.75,gamma:1.25,contrast:0.5,
                          \geom:1,renmode:5,taamode:1
  endif
endif

" Editing a protected file as 'sudo'
command! W w !sudo tee % > /dev/null

" ctags/gtags
"--------------------------------------------------------------------------------
" look tags in directory the current file in, and working directory,
" and looking up and up until /
set tags=./tags,tags,./.tags,.tags

" easytags: slow
let g:easytags_async=1
let g:easytags_dynamic_files = 1
let g:easytags_always_enabled=0
let g:easytags_on_cursorhold=0
let g:easytags_events = []

function! UpdateTags()
  execute ":silent !ctags -R --languages=C++ --c++-kinds=+p --fields=+iaS --extras=+q ./"
  execute ":redraw!"
  echohl StatusLine | echo "C/C++ tags updated" | echohl None
endfunction
command! CTags :call UpdateTags()

let $GTAGSLABEL = 'native-pygments'
let $GTAGSCONF = '/usr/local/share/gtags/gtags.conf'

" gutentags 
let g:gutentags_enabled = 0
if g:gutentags_enabled
" ÊêúÁ¥¢Â∑•Á®ãÁõÆÂΩïÁöÑÊ†áÂøóÔºåÁ¢∞Âà∞Ëøô‰∫õÊñá‰ª∂/ÁõÆÂΩïÂêçÂ∞±ÂÅúÊ≠¢Âêë‰∏ä‰∏ÄÁ∫ßÁõÆÂΩïÈÄíÂΩí
let g:gutentags_project_root = ['.root', '.svn', '.git', '.hg', '.project']
let g:gutentags_define_advanced_commands = 1
let g:gutentags_file_list_command = 'fd -t f'

" ÊâÄÁîüÊàêÁöÑÊï∞ÊçÆÊñá‰ª∂ÁöÑÂêçÁß∞
let g:gutentags_ctags_tagfile = 'tags'

" Â∞ÜËá™Âä®ÁîüÊàêÁöÑ tags Êñá‰ª∂ÂÖ®ÈÉ®ÊîæÂÖ• ~/.cache/tags ÁõÆÂΩï‰∏≠ÔºåÈÅøÂÖçÊ±°ÊüìÂ∑•Á®ãÁõÆÂΩï
let s:vim_tags = expand('~/.cache/tags')
let g:gutentags_cache_dir = s:vim_tags
if !isdirectory(s:vim_tags)
   silent! call mkdir(s:vim_tags, 'p')
endif

" ÂêåÊó∂ÂºÄÂêØ ctags Âíå gtags ÊîØÊåÅÔºö
let g:gutentags_modules = []
if executable('ctags')
  let g:gutentags_modules += ['ctags']
endif
if executable('gtags-cscope') && executable('gtags')
  let g:gutentags_modules += ['gtags_cscope']
endif

" ÈÖçÁΩÆ ctags ÁöÑÂèÇÊï∞
let g:gutentags_ctags_extra_args = ['--languages=C++']
let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
let g:gutentags_ctags_extra_args += ['--c-kinds=+px']
let g:gutentags_ctags_extra_args += ['--fields=+niazS', '--extras=+q']

" Â¶ÇÊûú‰ΩøÁî® universal ctags ÈúÄË¶ÅÂ¢ûÂä†‰∏ãÈù¢‰∏ÄË°åÔºåËÄÅÁöÑ Exuberant-ctags ‰∏çËÉΩÂä†‰∏ã‰∏ÄË°å
" let g:gutentags_ctags_extra_args += ['--output-format=e-ctags']
let g:gutentags_ctags_exclude = [
      \ '.git',
      \ '.svn',
      \ '*.git', '*.svg', '*.hg',
      \ '*/tests/*',
      \ 'build',
      \ 'dist',
      \ 'node_modules',
      \ 'vendor',
      \ '*.md',
      \ '*-lock.json',
      \ '*.lock',
      \ '*.json',
      \ '*.min.*',
      \ '*.pyc',
      \ 'tags*',
      \ 'cscope.*',
      \ '*bundle*.js',
      \ '*build*.js',
      \]

" Á¶ÅÁî® gutentags Ëá™Âä®Âä†ËΩΩ gtags Êï∞ÊçÆÂ∫ìÁöÑË°å‰∏∫
let g:gutentags_auto_add_gtags_cscope = 1
endif

" IME settings
"--------------------------------------------------------------------------------
function! Ime_en()
  let ts = localtime()
  let input_status = system('im-select')
  if input_status =~ "com.apple.keylayout.ABC"
    let b:inputtoggle = 0
  else
    let b:inputtoggle = 1
    call system('im-select com.apple.keylayout.ABC') "use en ime
  endif
endfunction

function! Ime_zh()
  try
    if b:inputtoggle == 1
      " Restore previous IME
      call system('im-select com.apple.inputmethod.SCIM.ITABC')
    endif
  catch /inputtoggle/
    let b:inputtoggle = 0
  endtry
endfunction

if has("mac")
  au! vimrc InsertLeave * call Ime_en()
  au! vimrc InsertEnter * call Ime_zh()
endif


let g:PaperColor_Theme_Options = {
      \   'theme': {
      \     'default.light': {
      \       'transparent_background': 1,
      \       'allow_bold': 1,
      \       'allow_italic': 0
      \     }
      \   },
      \   'language': {
      \     'python': {
      \       'highlight_builtins' : 1
      \     },
      \     'cpp': {
      \       'highlight_standard_library': 1
      \     },
      \     'c': {
      \       'highlight_builtins' : 1
      \     }
      \   }
      \ }

set background=light
" color gruvbox
if has("nvim")
  color vscode 
else
  color PaperColor
endif

if &background ==# 'light'
  exec 'hi SignColumn guibg=#eeeeee'
endif

"font
if has("gui_running")
  let s:font_size=17
  let s:fontbase="Bitstream_Vera_Sans_Mono"
  if has("mac")
    " let s:fontbase="PT_Mono"
    let s:fontbase="Hack_Nerd_Font_Mono"
    " let s:fontbase="SourceCodePro-Light"
    " let s:fontbase="SF_Mono"
    let s:fontwide="PingFangSC-Light"
  else
    " let s:fontbase="Ubuntu_Mono"
    " let s:fontbase="Anonymous_Pro"
    " let s:fontbase="Source_Code_Pro"
    let s:fontbase="Ubuntu_Mono"
    let s:fontwide="NSimSun"
  endif

  if !has('gui_vimr')
    execute "set guifont=". s:fontbase . ":h" . s:font_size
    execute "set guifontwide=". s:fontwide . ":h" . s:font_size
  endif

  map <leader>fi :call <SID>IncFontSize()<CR>
  map <leader>fo :call <SID>DecFontSize()<CR>
endif

function! s:IncFontSize()
  let s:font_size+=1
  execute "set guifont=". s:fontbase . ":h" . s:font_size
  execute "set guifontwide=". s:fontwide . ":h" . s:font_size
  echom s:font_size
endfunction

function! s:DecFontSize()
  let s:font_size-=1
  execute "set guifont=". s:fontbase . ":h" . s:font_size
  execute "set guifontwide=". s:fontwide . ":h" . s:font_size
  echom s:font_size
endfunction

" Insert a blank line
imap <C-Return> <CR><CR><C-o>k<Tab>

" Quick editing myvimrc
"--------------------------------------------------------------------------------
if !exists("$MYVIMRC")
  let $MYVIMRC = expand("<sfile>:p")
endif
map <leader>ev :e! $MYVIMRC<CR>
map <leader>eb :e! $VIMFILES/bundles.vim<CR>
map <silent> <leader>ss :lua if vim.fn.expand("%:e")=="lua" then vim.cmd("luafile %") else vim.cmd("source %") print("OK") end<cr>

" Smart way to move btw. windows
nnoremap <C-j> <C-W>j
nnoremap <C-k> <C-W>k
nnoremap <C-h> <C-W>h
nnoremap <C-l> <C-W>l

" Switch to current dir
map <leader>cd :lcd %:p:h<cr>:pwd<cr>

" Tab configuration
map <leader>tn :tabnew %<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove

imap jj <ESC>   " quick switch to normal mode

" Delete current line without yanking the line breaks
nnoremap dil ^d$
" Yank current line without the line breaks
nnoremap yil ^y$

" Move to begin of line / end to line
inoremap <C-e> <Esc>A
inoremap <C-a> <Esc>I
cnoremap <C-a> <C-b>

" Start browser
if has("win32")
  nmap <leader>ch :update<cr>:silent !"chrome.exe" "file://%:p"<cr>
endif
if has("mac")
  nmap <leader>ch :update<cr>:silent !open -a "Google Chrome" "%:p"<cr>:redraw!<cr>
endif


" Pascal configuration
"--------------------------------------------------------------------------------
autocmd vimrc BufReadPost *.pas,*.dpr set suffixesadd=.pas,.dpr,.txt,.dfm,.inc

" vim-json
let g:vim_json_syntax_conceal = 0

" emmet-vim
let g:user_emmet_leader_key=','

" UltiSnips
"--------------------------------------------------------------------------------
" Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
let g:UltiSnipsExpandTrigger="<C-k>"
let g:UltiSnipsListSnippets="<C-l>"
let g:UltiSnipsJumpForwardTrigger="<C-k>"
let g:UltiSnipsJumpBackwardTrigger="<C-p>"
let g:UltiSnipsEditSplit='horizontal'
let g:UltiSnipsSnippetDirectories = ["UltiSnips"]
let g:UltiSnipsSnippetsDir=expand('$VIMFILES/mysnippets/ultisnips')
set rtp+=$VIMFILES/mysnippets

" t.vim
let g:mysnippets_dir = expand("$VIMFILES/mysnippets")

" cmake
"--------------------------------------------------------------------------------
autocmd vimrc BufRead,BufNewFile *.cmake,CMakeLists.txt,*.cmake.in setf cmake
autocmd vimrc BufRead,BufNewFile *.ctest,*.ctest.in setf cmake
let g:cmake_default_config='Debug'
let g:cmake_build_type='Debug'
let g:cmake_export_compile_commands=1
let g:cmake_compile_commands=1
let g:cmake_ycm_symlinks=1

" vim-surroud
"--------------------------------------------------------------------------------
let g:surround_indent = 0 " Disable indenting for surrounded text
let g:surround_{char2nr("r")} = "üí• \r üí•"

" markdown
"--------------------------------------------------------------------------------
let g:vim_markdown_folding_disabled=0
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_folding = 3
let g:instant_markdown_autostart = 0
let g:instant_markdown_slow = 1

" there are some defaults for image directory and image name, you can change them
let g:mdip_imgdir = 'images'
" let g:mdip_imgname = 'image'
let s:mdctags_path = expand('$VIMFILES').'/tools/markdown2ctags.py'

let g:tagbar_type_markdown = {
            \ 'ctagsbin'  : s:mdctags_path,
            \ 'ctagsargs' : '-f - --sort=yes',
            \ 'kinds' : [
            \     's:sections',
            \     'i:images',
            \     '?:unknown',
            \   ],
            \ 'sro' : '|',
            \ 'kind2scope' : {
            \     's' : 'section',
            \   },
            \ 'sort': 0,
            \ }

" gulp
"--------------------------------------------------------------------------------
autocmd vimrc BufRead,BufNewFile gulpfile.js setlocal errorformat=%-G[%.%#,%f:%m,%-G%p,%-G%n%perror

" livedown
"--------------------------------------------------------------------------------
let g:livedown_autorun = 0

" should the browser window pop-up upon previewing
let g:livedown_open = 1

" ALE
"--------------------------------------------------------------------------------
let g:ale_enabled = 1
let g:ale_disable_lsp = 1 " use lsp with coc-nvim instead
let g:ale_linters = {
      \ 'javascript': ['eslint', 'prettier'],
      \ 'typescript': ['eslint', 'prettier'],
      \ 'python': ['flake8', 'pylint'],
      \ 'cpp': [],
      \ 'c': [],
      \}

let g:ale_echo_msg_format = "[%linter%] %s [%severity%]"
let g:ale_echo_msg_error_str="E"
let g:ale_echo_msg_warning_str = "W"
let g:ale_c_parse_compile_commands = 0
let g:ale_pattern_options_enabled = 1
let g:ale_pattern_options = {
      \ '\.min\.js$': {'ale_enabled': 0},
      \ '\.min\.css$': {'ale_enabled': 0},
      \}

let g:ale_fixers = {
      \ '*': ['remove_trailing_lines', 'trim_whitespace'],
      \ 'javascript': ['eslint'],
      \ 'typescript': ['eslint'],
      \ 'python': ['autopep8', 'yapf'],
      \}

" tcomment
"--------------------------------------------------------------------------------
let g:tcomment#options_comments = {'whitespace': 'left'}
let g:tcomment#options_commentstring = {'whitespace': 'left'}

" nerdcommenter
"--------------------------------------------------------------------------------
" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1

" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1

" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'

" Set a language to use its alternate delimiters by default
let g:NERDAltDelims_java = 1

" Add your own custom formats or override the defaults
let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }

" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1

" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1

" Enable NERDCommenterToggle to check all selected lines is commented or not
let g:NERDToggleCheckAllLines = 1


"--------------------------------------------------------------------------------
" tagbar/vista settings
"--------------------------------------------------------------------------------
" map <leader>t :TagbarToggle<cr>
" let g:tagbar_compact = 1
" if filereadable($VIMFILES . '/tagbar.conf')
"     source $VIMFILES/tagbar.conf
" endif
let g:vista_fzf_preview = ['right:50%']
let g:vista#renderer#enable_icon = 1
let g:vista_executive_for = {
  \ 'vim': 'coc',
  \ 'typescript': 'coc',
  \ 'javascript': 'coc',
  \ 'cpp': 'coc',
  \ 'c': 'coc',
  \ 'markdown': 'toc',
  \ }
let g:vista#renderer#icons = {
\   "function": "\uf794",
\   "variable": "\uf71b",
\  }
let g:vista_icon_indent = ["‚ï∞‚îÄ‚ñ∏ ", "‚îú‚îÄ‚ñ∏ "]
let g:vista_default_executive = "coc"

function! NearestMethodOrFunction() abort
  return get(b:, 'vista_nearest_method_or_function', '')
endfunction

set statusline+=%{NearestMethodOrFunction()}
autocmd VimEnter * call vista#RunForNearestMethodOrFunction()

map <leader>t :Vista!!<cr>

"--------------------------------------------------------------------------------
" vim-session settings
"--------------------------------------------------------------------------------
let g:session_autosave='prompt'
let g:session_autoload='no'
let g:session_autosave_periodic=0

"--------------------------------------------------------------------------------
" airline settings
"--------------------------------------------------------------------------------
let g:airline#extensions#ale#enabled = 1
let g:airline#extensions#coc#enabled = 1
let g:airline#extensions#tagbar#enabled = 0
let g:airline#extensions#tmuxline#enabled = 0
let g:airline_section_b = '' "'%-20{getcwd()}'

"--------------------------------------------------------------------------------
" Search the selected text
"--------------------------------------------------------------------------------
function! s:getSelectedText()
  let l:old_reg = getreg('"')
  let l:old_regtype = getregtype('"')
  norm gvy
  let l:ret = getreg('"')
  call setreg('"', l:old_reg, l:old_regtype)
  exe "norm \<Esc>"
  return l:ret
endfunction
vnoremap <silent> * :call setreg("/",
    \ substitute(<SID>getSelectedText(),
    \ '\_s\+',
    \ '\\_s\\+', 'g')
    \ )<Cr>n

vnoremap <silent> # :call setreg("?",
    \ substitute(<SID>getSelectedText(),
    \ '\_s\+',
    \ '\\_s\\+', 'g')
    \ )<Cr>n

"--------------------------------------------------------------------------------
" fzf: File searching
"--------------------------------------------------------------------------------
" An action can be a reference to a function that processes selected lines
function! s:build_quickfix_list(lines)
  call setqflist(map(copy(a:lines), '{ "filename": v:val }'))
  copen
  cc
endfunction

let g:ctrlp_map = ''

let g:fzf_action = {
  \ 'ctrl-q': function('s:build_quickfix_list'),
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit'
  \}

" - Popup window
let g:fzf_layout = { "down": "50%" }

" fzf binding
nnoremap <C-P> :Files<CR>
nnoremap <leader>ff :Files<CR>
nnoremap <leader>fb :Buffers<CR>
nnoremap <leader>b :Buffers<CR>
nnoremap <leader>fh :History<CR>

" settings for t.vim
function! s:search_template(arg, bang)
  let all = len(&ft) == 0 || a:arg =~ 'a'
  call fzf#vim#files((all? g:mysnippets_dir : g:mysnippets_dir . '/' . &ft),
        \ fzf#vim#with_preview({'sink': 'r', 'options': [ '--info=inline']}),
        \ a:bang)
endfunction

command! -bang -nargs=? Ft call s:search_template(<q-args>, <bang>0)
nmap <leader>ft :Ft<CR>

"--------------------------------------------------------------------------------
" The Silver Searcher
"--------------------------------------------------------------------------------
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor\ --column
  set grepformat=%f:%l:%c%m

  "Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  "let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
  "Note that other CtrlP options related to which files get included in the index
  "(g:ctrlp_show_hidden, wildignore, g:ctrlp_custom_ignore, g:ctrlp_max_files, g:ctrlp_max_depth, g:ctrlp_follow_symlinks)
  "do not apply when using g:ctrlp_user_command.
  let g:ctrlp_user_command = 'ag %s -l --nocolor --nogroup
         \ --ignore .git --ignore .svn --ignore .hg --ignore .DS_Store
         \ --ignore .cache --ignore .npm --ignore .idea --ignore .m2 -g ""'
  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0

  " Ag command
  command! -nargs=+ -complete=file -bar Ag silent! grep! <args>|cwindow|redraw!
endif


"Man
"--------------------------------------------------------------------------------
runtime ftplugin/man.vim

"vim-easy-align
"--------------------------------------------------------------------------------
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)


"load local customized script
"--------------------------------------------------------------------------------
if filereadable(expand("~/.vimrc.local"))
    source ~/.vimrc.local
endif

"Convert selected text to javascript string
"--------------------------------------------------------------------------------
function! s:ToJS(sep, first_line, last_line)
    let i = a:first_line
    while i<=a:last_line
      let l = getline(i)
      let l = substitute(l, a:sep, "\\\\".a:sep, "g")
      if i==a:last_line
        call setline(i, a:sep . l . a:sep . ";" )
      else
        call setline(i, a:sep . l . a:sep . " + " )
      endif
      let i=i+1
    endwhile
endfunction
command!  -nargs=1 -range ToJs call s:ToJS(<q-args>, <line1>, <line2>)

"Apply macro on selected lines
"--------------------------------------------------------------------------------
xnoremap @ :<C-u>call ExecuteMacroOverVisualRange()<CR>
function! ExecuteMacroOverVisualRange()
  echo "@".getcmdline()
  execute ":'<,'>normal @".nr2char(getchar())
endfunction

"NERDTree
"--------------------------------------------------------------------------------
noremap <F3> :NERDTreeToggle<cr>
noremap <leader>nf :NERDTreeFind<cr>
let g:NERDTreeWinSize=40

" Quick unescape xml entities
"--------------------------------------------------------------------------------
function! XmlUnescape()
  silent! execute ':%s/&lt;/</g'
  silent! execute ':%s/&gt;/>/g'
  silent! execute ':%s/&amp;/\&/g'
endfunction
command! -nargs=0 XmlUnescape :call XmlUnescape()
nnoremap <leader>xf :call XmlUnescape()

" Unescape \uXXXX sequences in selected lines
"--------------------------------------------------------------------------------
function! UnescapeUnicode() range
  let cmd = a:firstline . "," . a:lastline . 's/\\u\(\x\{4\}\)/\=nr2char("0x".submatch(1),1)/g'
  silent! execute cmd
endfunction
command! -nargs=0 -range=% UnescapeUnicode :<line1>,<line2>call UnescapeUnicode()

" Convert rows of numbers or text (as if pasted from excel column) to a tuple
"--------------------------------------------------------------------------------
function! ToTupleFunction() range
    silent execute a:firstline . "," . a:lastline . "s/^/'/"
    silent execute a:firstline . "," . a:lastline . "s/$/',/"
    silent execute a:firstline . "," . a:lastline . "join"
    silent execute "normal I("
    silent execute "normal $xa)"
    silent execute "normal ggVGYY"
endfunction
command! -range ToTuple <line1>,<line2> call ToTupleFunction()

" Dot
"--------------------------------------------------------------------------------
function! Dot(bang, format)
    let fmt = a:format
    if empty(fmt)
      let fmt = 'png'
    endif
    let cmd = '!dot'
    let opt = ' -T' . fmt . ' -o '
    let currfile = expand('%:p')
    let outfile = expand('%:p:r') . '.' . fmt
    echom opt
    silent execute cmd . ' "' . currfile . '" '. opt . ' "' . outfile . '" '
    if a:bang
      call system('open ' . outfile)
    endif
endfunction
command! -nargs=* -bang Dot :call Dot(<bang>0, <q-args>)|redraw!
let g:WMGraphviz_output = "svg"

let g:previm_open_cmd = 'open -a "google chrome"'

" vim-go / golang
"--------------------------------------------------------------------------------
let g:go_fmt_fail_silently = 1
let g:go_snippet_engine='ultisnips'
let g:go_doc_popup_window = 1

let g:go_term_mode = "split"
let g:go_term_enabled = 1
let g:go_term_reuse = 1
let g:go_term_width = 80
let g:go_term_height = 10
let g:go_term_close_on_exit = 0

autocmd vimrc Filetype go noremap <buffer> <leader>rt :GoTestFunc<cr>
autocmd vimrc Filetype go noremap <buffer> <leader>r :QuickRun<cr>
autocmd vimrc Filetype go noremap <buffer> <f9> :QuickRun<cr>

" abbrev
autocmd vimrc Filetype go ca <buffer> ips GoImports
autocmd vimrc Filetype go noremap <buffer> <F5> :GoBuild<cr>
autocmd vimrc Filetype go command! -buffer -bang A call go#alternate#Switch(<bang>0, 'edit')
autocmd vimrc Filetype go command! -buffer -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
autocmd vimrc Filetype go command! -buffer -bang AS call go#alternate#Switch(<bang>0, 'split')
autocmd vimrc Filetype go command! -buffer -bang AT call go#alternate#Switch(<bang>0, 'tabe')


" clang_format
"--------------------------------------------------------------------------------
let g:clang_format#style_options = {
            \ "ColumnLimit": 0,
            \ "AllowShortIfStatementsOnASingleLine" : "true",
            \ "AlwaysBreakTemplateDeclarations" : "true",
            \ "Standard" : "C++17"}

" let g:clang_format#command='/usr/local/bin/clang-format'
autocmd vimrc FileType c,cpp,objc,objcpp nnoremap <buffer> <Leader>cf :<C-u>ClangFormat<CR>
autocmd vimrc FileType c,cpp,objc,objcpp vnoremap <buffer> <Leader>cf :ClangFormat<CR>
autocmd vimrc FileType c,cpp,objc,objcpp nmap <buffer> <Leader>C :ClangFormatAutoToggle<CR>

" YCM & Coc.nvim
"--------------------------------------------------------------------------------
let g:ycm_filetype_blacklist = {}
if $VIM_MODE =~ 'ycm'
  source $VIMFILES/config-ycm.vim
elseif $VIM_MODE =~ 'coc'
  source $VIMFILES/config-coc.vim
endif

" victionary
"--------------------------------------------------------------------------------
let g:victionary#map_defaults = 0

" Polyglot
"--------------------------------------------------------------------------------
let g:polyglot_disabled=['typescript', 'go']

" Draw ascii box
"--------------------------------------------------------------------------------
map <leader>tsk :call ToggleSketch()<CR>

" Any-jump
"--------------------------------------------------------------------------------
let g:any_jump_disable_default_keybindings = 1
let g:any_jump_search_prefered_engine = 'ag'

" Jump to definition under cursore
nnoremap gs :AnyJump<CR>

" Visual mode: jump to selected text in visual mode
xnoremap gs :AnyJumpVisual<CR>
" open last closed search window again
nnoremap gl :AnyJumpLastResults<CR>

" Disable tmux navigator when zooming the Vim pane
"--------------------------------------------------------------------------------
let g:tmux_navigator_disable_when_zoomed = 1

" vim-emoji
set completefunc=emoji#complete

" EasyMotion
"--------------------------------------------------------------------------------
let g:EasyMotion_do_mapping = 0 " Disable default mappings

" Jump to anywhere you want with minimal keystrokes, with just one key binding.
" `s{char}{label}`
nmap s <Plug>(easymotion-overwin-f)
" or
" `s{char}{char}{label}`
" Need one more keystroke, but on average, it may be more comfortable.
nmap s <Plug>(easymotion-overwin-f2)

" Turn on case-insensitive feature
let g:EasyMotion_smartcase = 1

" JK motions: Line motions
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)

" vimspector
let g:vimspector_enable_mappings = 'HUMAN'

" rust
let g:rustfmt_autosave = 1

" vim-test
if has('nvim')
  let g:test#strategy = "neovim"
endif
nmap <silent> t<C-n> :TestNearest<CR>
function! DebugNearest()
  let g:test#go#runner = 'delve'
  TestNearest
  unlet g:test#go#runner
endfunction
nmap <silent> t<C-d> :call DebugNearest()<CR>

" terminal
tnoremap <Esc> <C-\><C-n>  " to exit terminal-mode
tnoremap <C-h> <C-\><C-N><C-w>h
tnoremap <C-j> <C-\><C-N><C-w>j
tnoremap <C-k> <C-\><C-N><C-w>k
tnoremap <C-l> <C-\><C-N><C-w>l

" quickrun
let g:quickrun_no_default_key_mappings = 1 " Disable the default keymap to ,r
autocmd vimrc Filetype lua noremap <buffer> <leader>r :QuickRun<cr>
autocmd vimrc Filetype lua noremap <buffer> <f9> :QuickRun<cr>

" enable syntax highlight for embeded lua & python code
let g:vimsyn_embed = 'lP'

if has('nvim')
  " source lua config
  luafile $VIMFILES/lua/config.lua
else
  let g:loaded_gzip = 1
  let g:loaded_zip = 1
  let g:loaded_zipPlugin = 1
  let g:loaded_tar = 1
  let g:loaded_tarPlugin = 1
  let g:loaded_getscript = 1
  let g:loaded_getscriptPlugin = 1
  let g:loaded_vimball = 1
  let g:loaded_vimballPlugin = 1
  let g:loaded_2html_plugin = 1
  let g:loaded_matchit = 1
  let g:loaded_matchparen = 1
  let g:loaded_logiPat = 1
  let g:loaded_rrhelper = 1
  let g:loaded_netrw = 1
  let g:loaded_netrwPlugin = 1
  let g:loaded_netrwSettings = 1
  let g:loaded_netrwFileHandlers = 1
endif

fun! Profiling()
  if !exists('s:profiling_active')
    echom "Profiling activated"
    let s:profiling_active = 1
    if has('nvim')
      profile start nprofile.log
    else
      profile start profile.log
    endif
    profile func *
    profile file *
  else
    profile pause
    noautocmd qall!
  endif
endfun

" Load machine specific configurations
"--------------------------------------------------------------------------------
if filereadable(expand("~/.vimrc.after"))
  source ~/.vimrc.after
endif
